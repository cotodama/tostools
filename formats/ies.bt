// ies

char fName[64]; // datatable name
Printf("Table: %s\n\n", fName);

/////////////////////////////////////////////////////////////
// ignore these functions, they're just to handle how stuff can be read
struct drowd
{
  unsigned byte Num[4];
  local int Value = Num[3]*16777216 + Num[2]*65536 + Num[1]*256 + Num[0];
};

struct itm
{
  char encString[64];
};

struct ss // reads string length based on size indicator
{
  short StringSize;
  if(StringSize > 0)
    char String[StringSize];
  else
    local char String[1];
};

// descramble string
string DecString( char Str[255] ) // real max. string size is 65535
{
  if(Str == "none")  return Str;  // assumed

  local char s[255];
  local int i;

  for(i=0; i < sizeof(Str); i++)
  {
    if(Str[i] == 0) break;

    if(Str[i] % 2 == 1) s[i] = Str[i] - 1;
    else  s[i] = Str[i] + 1;
  }

  return s;
}
////////////////////////////////////////////////////////////

FSkip(4); // always 1
drowd UNB, UNC, Size;

if(Size.Value != FileSize())
{
  Printf("WARNING Stored size does not match actual size!");
  Warning("Filesize error");
}

FSkip(2); // always 1
short Rows, Columns;

short ColInt, ColString; // expected column types

if(ColString + ColInt != Columns)
{
  Printf("ERROR Wrong number of column type descriptors");
  return -1;
}

Printf("%i Columns:\n", Columns);

local int c, d, totStrings;
totStrings = 0;

/*
  Not sure which way round this is declared at
*/

//FSeek(Size.Value - (UNC.Value + UNB.Value));

for(c=0; c<Columns; c++) // column headers
{
  short un__NEW;
  itm Header1, Header2; // duplicate data
  
  int ColType; // 0 = Number, 1 = String
  
  //short UnknownS;

  Printf(" %s:\t(%i) %s\n", ((ColType == 1) ? "[Str]" : "[Num]" ), un__NEW, DecString(Header1.encString));

  if(ColType == 1) totStrings++; // count number of expected string columns
}

if(totStrings != ColString)
{
  Printf("ERROR Unexpected number of string columns");
  return -1;
}

short xx;

for(d=0; d<Rows; d++) // row data
{
  int xyx; // row count?

  short ssize; // generally 0, rarely a string size
  FSkip(ssize);

  for(c=0; c<ColInt; c++)
  {
    FSkip(4); // a number type (float?)
  }

  for(c=0; c<ColString; c++)
  {
    short fskip_str;
    FSkip(fskip_str); // a string type
  }

  FSkip(ColString); // number of string types
}

if(FileSize() == FTell())
{
  Printf("File was parsed successfully!\n");
  return;
}

return -1;